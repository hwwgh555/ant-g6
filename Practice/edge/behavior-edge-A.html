<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Tutorial Demo--G6</title>
    <style>
        body {
            background-color: #f2f5f7;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script type="text/javascript"
        src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.7.1/dist/g6.min.js"></script>
    <script>

        const fittingString = (str, lineWidth, fontSize) => {
            let currentWidth = 0;
            let res = str;
            let lineCount = 1;
            let strArr = []
            // 匹配中文正则
            const pattern = new RegExp('[\u4E00-\u9FA5]+');
            str.split('').forEach((letter, i) => {
                if (pattern.test(letter)) {
                    // getLetterWidth 似乎计算不准确
                    currentWidth += fontSize;
                } else {
                    currentWidth += G6.Util.getLetterWidth(letter, fontSize);
                }
                if (currentWidth > lineWidth) {
                    strArr.push(`${letter}\n`)
                    lineCount++
                    currentWidth = 0
                } else {
                    strArr.push(letter)
                }
            });
            res = strArr.join('')

            return {
                linesStr: res,
                lineCount,
            }
        }

        const $container = document.querySelector('#container');
        const DRAG_NODE_MODE = 'dragNode'
        const ADD_EDGE_MODE = 'addEdge'
        const DEFAULT_ANSWERS = [
            {
                label: '肯定',
            },
            {
                label: '否定',
            },
            {
                label: '未知',
            },
        ]

        // 第一次渲染拿到的宽度是正常的 this.wrapperWidth
        let isFirstRender = true

        // 颜色应该是放在COLOR中，还是放在对应的块中？
        const COLOR = {
            primary: '#1FCDCF',
            hoverPrimary: '#b4eaeb',
            white: '#FFFFFF',
            gray: '#f2f5f7',
        }

        const WRAPPER = {
            paddingTop: 10,
            paddingLeft: 5,
        }

        const FAVIROTE = {
            width: 40,
            icon: './icons/close.png',
        }

        const HEADER = {
            selected: '',
            paddingLeft: 10,
            paddingTop: 5,
            MAX_WIDTH: 500,
            title: {
                fontSize: 16,
                lineHeight: 30,
            },
            content: {
                fontSize: 14,
                lineHeight: 20,
            },
        }

        const BOTTOM_TITLE = {
            paddingTop: 5,
            lineHeight: 15,
        }

        /*
            ANSWER模型 -- 类似css的盒模板
        */
        const ANSWER = {
            top: 80, // 参考起始点
            xSpace: 20, // 多个Answer之间的距离
            paddingTop: 2, // 文字与Answer边框的距离
            paddingLeft: 8,
            addIconWidth: 20,
            bg: '#fff',
            color: '#000',
            fontSize: 14,
            height: 18,
        }

        G6.registerBehavior('change-mode', {
            getEvents() {
                return {
                    /*
                        * onMouseover可以区分不同 shape，在同一个shape中只触发一次
                        * add-edge激活drag中，托动到其它shape时，不会再触发 -- dom event也是这样吗？
                    */
                    'node:mouseover': 'onNodeMouseover',
                }
            },
            getIsEdgeLinkShape(ev) {
                // 1.待提取 2.待思考 -- 值的设置到底是怎样的？
                const curShape = ev.target
                return !!curShape.get('custom-isEdgeLinkPoint')
            },
            onNodeMouseover(ev) {
                const isEdgeLinkPoint = this.getIsEdgeLinkShape(ev)
                if (isEdgeLinkPoint) {
                    this.graph.setMode(ADD_EDGE_MODE)
                } else {
                    this.graph.setMode(DRAG_NODE_MODE)
                }
            },
        })

        G6.registerBehavior('add-edge', {
            getEvents() {
                return {
                    'node:dragstart': 'onNodeDragstart',
                    drag: 'onNodeMousemouse',
                    'node:drop': 'onNodeDrop',
                    dragend: 'onDragend'
                }
            },
            getIsEdgeLinkShape(ev) {
                const curShape = ev.target
                return !!curShape.get('custom-isEdgeLinkPoint')
            },
            getSourceAnchor(ev) {
                // 通过对比预定义的anchorPoints的x轴与拖动时的起始点坐标x，近的即是
                const { x } = ev
                const item = ev.item
                const { minX, width } = item.getBBox()
                // anchorPoints数据中定义的；getAnchorPoints 自定义图形中的方法
                const model = item.getModel()
                const anchorPoints = model.anchorPoints || item.getAnchorPoints()
                const cursorPoint = x
                if (anchorPoints.length === 1) {
                    return -1
                }
                if (anchorPoints.length === 2) {
                    return 1
                }
                let target = {
                    index: 0,
                    value: 0,
                }
                anchorPoints.slice(1).forEach((item, index) => {
                    const xDis = Math.abs(cursorPoint - item.x)
                    if (index === 0) {
                        target.index = index
                        target.value = xDis
                    } else {
                        const isSmaller = xDis < target.value
                        if (isSmaller) {
                            target.index = index
                            target.value = xDis
                        }
                    }
                })
                return target.index + 1
            },
            onNodeDragstart(ev) {
                ev.stopPropagation()
                ev.preventDefault()
                const isEdgeLinkPoint = this.getIsEdgeLinkShape(ev)
                if (!isEdgeLinkPoint) return
                const graph = this.graph
                const node = ev.item
                const model = node.getModel()
                /* soureAnchor如何实现与配置项 相一致呢？
                    * 二者计算位置的方式一致化
                */
                this.edge = graph.addItem('edge', {
                    source: model.id,
                    target: model.id,
                    sourceAnchor: this.getSourceAnchor(ev),
                })
                // 新加了一个id作为对比
                this.source = model.id
                this.addingEdge = true
            },
            onDragend(ev) {
                // 模仿antd内置的库的 create-edge处理
                const { item } = ev
                if (!item || item.getID() === this.source || item.getType() !== 'node') {
                    if (this.addingEdge && this.edge) {
                        this.graph.removeItem(this.edge)
                        this.edge = null
                        this.addingEdge = false
                    }
                }
            },
            onNodeDrop(ev) {
                if (ev.item.getModel().isStartNode) {
                    // TODO:
                    if (this.addingEdge && this.edge) {
                        this.graph.removeItem(this.edge)
                        this.edge = null
                        this.addingEdge = false
                    }
                    return
                }
                if (this.edge && this.addingEdge) {
                    this.graph.updateItem(this.edge, {
                        target: ev.item.getModel().id,
                        targetAnchor: 0,
                    })
                    // 如何主动调用 自动布局？
                    // this.graph.execute()
                    this.addingEdge = false
                    this.edge = null
                    // 重新布局 缺陷会导致 突然缩小，或放大
                    // this.graph.updateLayout({})
                    graph.updateLayout({
                        ranksep: 10,
                    })
                    // this.graph.data(this.graph.save())
                    // this.graph.render()
                }
            },
            onNodeMousemouse(ev) {
                if (this.edge && this.addingEdge) {
                    this.graph.updateItem(this.edge, {
                        target: {
                            x: ev.x,
                            y: ev.y,
                        }
                    })
                }
            },
        })


        G6.registerNode('myNode', {
            draw(cfg, group) {

                const headerTitleLineHeight = HEADER.title.lineHeight

                // 这个方法待合并
                const getLabelWidth = (label) => {
                    if (!label) {
                        // 最小值
                        return 8 + 24 + 8
                    }
                    return label.split('').length * ANSWER.fontSize
                }

                const getAnswersWidth = (answers) => {
                    const getWidth = (arr) => {
                        let width = 0
                        arr.forEach((item) => {
                            width += ANSWER.paddingLeft * 2 + ANSWER.xSpace + getLabelWidth(item.label)
                        })
                        return width
                    }
                    const width = getWidth(answers) + ANSWER.addIconWidth
                    const minWidth = getWidth(DEFAULT_ANSWERS) + ANSWER.addIconWidth

                    return minWidth > width ? minWidth : width
                    return width
                }
                const lineWidth = getAnswersWidth(cfg.answers)
                const wrapperWidth = WRAPPER.paddingLeft + FAVIROTE.width + lineWidth
                if (isFirstRender) {
                    this.wrapperWidth = wrapperWidth // 方便计算节点时使用
                    isFirstRender = false
                }
                // 文字计算有差异
                const { linesStr, lineCount } = fittingString(cfg.content, lineWidth - HEADER.paddingLeft * 2, HEADER.content.fontSize)
                const headerCotentHeight = HEADER.content.lineHeight * lineCount
                const headerHeight = HEADER.paddingTop * 3 + headerTitleLineHeight + headerCotentHeight
                const headerWidth = lineWidth
                const bottomTitleHeight = BOTTOM_TITLE.paddingTop * 2 + BOTTOM_TITLE.lineHeight
                /*
                    最外层宽度： 收藏(固定) +  或者 answers宽度
                    最外层高度:  标题部分（主体部分是动态的） + 客户回答(固定) + 回复(固定)
                */
                const keyShape = group.addShape('rect', {
                    attrs: {
                        stroke: '#0000FF',
                        fill: COLOR.gray,
                        width: wrapperWidth, // 是由 answer的多少来决定的
                        height: WRAPPER.paddingTop + headerHeight + bottomTitleHeight + ANSWER.paddingTop * 2 + ANSWER.height, // 由纵向内容区决定
                    },
                    name: 'rect-shape'
                })

                /*
                    收藏图标
                    y =  padding + 标题部分高度的中间部分
                */
                group.addShape('image', {
                    attrs: {
                        x: 5,
                        y: WRAPPER.paddingTop + headerHeight / 2 - ANSWER.fontSize, // 动态计算
                        img: FAVIROTE.icon,
                        width: 30,
                        height: 30,
                        cursor: 'pointer',
                    },
                    capture: true,
                    name: `favirote-icon`,
                })

                // start= header 主体文字说明
                group.addShape('rect', {
                    attrs: {
                        stroke: '#0000FF',
                        /* 存在3种
                            未选中：'#FFFFFF'
                            hover: '#b4eaeb'
                            选中: COLOR.primary
                        */
                        fill: COLOR.white,
                        x: FAVIROTE.width,
                        y: WRAPPER.paddingTop,
                        width: headerWidth,
                        height: headerHeight,
                    },
                    draggable: true, // 设置为true时，drag-node才会生效
                    name: 'rect-shape'
                })

                if (cfg.label) {
                    group.addShape('text', {
                        attrs: {
                            text: cfg.label,
                            x: FAVIROTE.width + HEADER.paddingLeft,
                            y: WRAPPER.paddingTop + HEADER.paddingTop,
                            fontSize: HEADER.title.fontSize,
                            lineHeight: HEADER.title.lineHeight,
                            textAlign: 'left',
                            textBaseline: 'top', // 参考点位于 文字的坐标的上方
                            fill: '#3D4966',
                        },
                        capture: true,
                        draggable: true,
                        name: 'text-shape'
                    })
                }
                if (cfg.content) {
                    group.addShape('text', {
                        attrs: {
                            x: FAVIROTE.width + HEADER.paddingLeft,
                            y: WRAPPER.paddingTop + HEADER.paddingTop + headerTitleLineHeight,
                            text: linesStr, // 多行文本
                            fontSize: HEADER.content.fontSize,
                            lineHeight: HEADER.content.lineHeight,
                            textAlign: 'left',
                            textBaseline: 'top', // 参考点位于 文字的坐标的上方
                            fill: '#3D4966', // TODO: 提取
                        },
                        draggable: true,
                        name: 'text-shape'
                    })
                }
                //=end header

                // 客户回复
                group.addShape('text', {
                    attrs: {
                        x: FAVIROTE.width,
                        y: WRAPPER.paddingTop + headerHeight + BOTTOM_TITLE.paddingTop,
                        text: '客户回复:',
                        textAlign: 'left',
                        textBaseline: 'top',
                        fill: '#999999',
                        fontSize: ANSWER.fontSize,
                        cursor: 'pointer',
                    },
                    capture: true,
                    name: `client-name`
                })

                if (cfg.answers) {
                    const answers = cfg.answers

                    // 添加group之后， item.target 还能不能获取相应的shape? TODO:

                    let lastLeft = FAVIROTE.width
                    answers.forEach((itm, idx) => {
                        // 分支外框
                        const width = ANSWER.paddingLeft * 2 + getLabelWidth(itm.label)
                        group.addShape('rect', {
                            attrs: {
                                x: lastLeft,
                                y: WRAPPER.paddingTop + headerHeight + bottomTitleHeight + ANSWER.paddingTop,
                                width: width,
                                height: ANSWER.height,
                                radius: 1,
                                fill: COLOR.white,
                                stroke: COLOR.white,
                                cursor: 'pointer',
                            },
                            capture: true,
                            'custom-isEdgeLinkPoint': true, // 自定义属性，用于区分 keyShape
                            draggable: true,
                            name: `${idx}-answer-rect`
                        })
                        // 分支文字
                        group.addShape('text', {
                            attrs: {
                                x: lastLeft + ANSWER.paddingLeft,
                                y: WRAPPER.paddingTop + headerHeight + bottomTitleHeight + ANSWER.paddingTop,
                                text: itm.label ? itm.label : '',
                                textAlign: 'left',
                                textBaseline: 'top',
                                fill: COLOR.primary, // 有点奇怪 TODO:
                                fontSize: ANSWER.fontSize,
                                cursor: 'pointer',
                            },
                            'custom-isEdgeLinkPoint': true, // 自定义属性，用于区分 keyShape
                            draggable: true,
                            capture: true,
                            name: `${idx}-answer-text`
                        })
                        //分支关闭图标
                        group.addShape('image', {
                            attrs: {
                                x: lastLeft + width - 7, // 需要计算图标宽度
                                y: WRAPPER.paddingTop + headerHeight + bottomTitleHeight + ANSWER.paddingTop - 5,
                                img: './icons/close.png',
                                cursor: 'pointer',
                            },
                            capture: true,
                            name: `${idx}-answer-close-icon`
                        })
                        lastLeft += width + ANSWER.xSpace
                    })
                    group.addShape('image', {
                        attrs: {
                            x: lastLeft,
                            y: WRAPPER.paddingTop + headerHeight + bottomTitleHeight + ANSWER.paddingTop,
                            img: './icons/add.png',
                            cursor: 'pointer',
                        },
                        capture: true,
                        name: `answer-add-icon`
                    })
                }
                return keyShape
            },
            update(cfg, node) {
                console.log('update::', cfg, node)
                const group = node.getContainer()
                // if (cfg['custom-update']) {
                //     const updateInfo = cfg['custom-update']
                //     const idx = updateInfo.name.split('-')[0]
                //     const cloaseIconShape = group.find((ele) => ele.get('name') === updateInfo.name)
                //     const rectShape = group.find((ele) => ele.get('name') === `${idx}-answer-rect`)
                //     const txtShape = group.find((ele) => ele.get('name') ===  `${idx}-answer-text`)

                //     if (updateInfo.type === 'remove') {
                //         group.removeChild(cloaseIconShape)
                //         group.removeChild(rectShape)
                //         group.removeChild(txtShape)
                //     }
                // }
                // group.clear()
            },
            afterUpdate(cfg, node) {
                // console.log('afterUpdate::', cfg, node)
            },
            // setState() {

            // }
            getAnchorPoints(cfg) {
                // 这里是被动触发的
                const answers = cfg.answers
                // 这个方法待合并
                const getLabelWidth = (label) => {
                    if (!label) {
                        // 最小值
                        return 8 + 24 + 8
                    }
                    return label.split('').length * ANSWER.fontSize
                }
                let lastLeft = FAVIROTE.width
                const anchors = answers.map((item, idx) => {
                    const width = ANSWER.paddingLeft * 2 + getLabelWidth(item.label)
                    // wrapperWidth从自定义节点中，拿到 wrapperWidth 是不对的
                    const pos = (lastLeft + width / 2) / this.wrapperWidth
                    lastLeft += width + ANSWER.xSpace
                    return [pos, 1]
                })
                return [[0.5, 0]].concat(anchors)
            }
        })

        const graph = new G6.Graph({
            container: 'container',
            width: $container.scrollWidth,
            height: $container.scrollHeight || 1000,
            defaultEdge: {
                style: {
                    endArrow: true,
                }
            },
            defaultNode: {
                type: 'rect'
            },
            // fitView: true,
            layout: {
                type: 'dagre',
                // align: 'DL',
                // 同一层 节点间间距
                nodesepFunc: (cfg) => {
                    // 要想精确计算 取决于前一个节点 需要拿到edge信息 可以从data中取到，然后再提取成要处理的数据类型
                    if (cfg.id === 'node2-2') {
                        // 动态计算 TODO:
                        return 200
                    }
                    return 200
                },
                // 层级间距
                ranksepFunc: (cfg, ...args) => {
                    // 动态计算 TODO
                    return 60
                },
            },
            modes: {
                // default: [ADD_LINE_MODE],
                default: ['change-mode', 'drag-node', 'drag-canvas'],
                [DRAG_NODE_MODE]: ['change-mode', 'drag-node', 'drag-canvas'],
                [ADD_EDGE_MODE]: ['change-mode', 'add-edge', 'drag-canvas'],
            }
        })

        const data = {
            nodes: [
                {
                    id: 'node1',
                    label: '开始开始开始开始开始',
                    // content: '不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！',
                    content: 'xx',
                    type: 'myNode',
                    isStartNode: true, // 初始节点的特别设置 是否可以向其连线
                    // anchorPoints: [
                    //     [0.5, 0],
                    //     [0.4, 0.8],
                    //     [0.7, 0.8],
                    // ],
                    answers: DEFAULT_ANSWERS,
                    // 这里是多个时下面的 连接点 计算不正常 TDDO:
                    // answers: [
                    //     {
                    //         label: '肯定',
                    //     },
                    //     {
                    //         label: '否定',
                    //     },
                    //     {
                    //         label: '未知1',
                    //     },
                    //     {
                    //         label: '未知2',
                    //     },
                    //     {
                    //         label: '未知3',
                    //     },
                    // ]
                },
                {
                    id: 'node2-1',
                    label: '开始开始开始开始开2-1',
                    content: '不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！',
                    content: '有点意思',
                    type: 'myNode',
                    answers: DEFAULT_ANSWERS,
                },
                {
                    id: 'node2-2',
                    label: '开始开始开始开始开2-2',
                    content: '不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！',
                    // content: '有点意思',
                    type: 'myNode',
                    answers: DEFAULT_ANSWERS,
                },
                {
                    id: 'node3-1',
                    label: '开始开始开始开始开3-1',
                    content: '不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！不好意思打扰了，祝您生活娱快！',
                    content: '有点意思',
                    type: 'myNode',
                    answers: DEFAULT_ANSWERS,
                },
                // {
                //     id: 'node3',
                //     label: 'node3',
                //     size: [100, 50],
                //     type: 'myNode',
                //     anchorPoints: [
                //         [0.5, 0],
                //         [0.4, 0.8],
                //         [0.7, 0.8],
                //     ],
                // },
                // {
                //     id: 'node4',
                //     label: 'node4',
                //     size: [100, 50],
                //     type: 'myNode',
                //     anchorPoints: [
                //         [0.5, 0],
                //         [0.4, 0.8],
                //         [0.7, 0.8],
                //     ],
                // },
            ],
            // edges: [
            //     {
            //         source: 'node1',
            //         target: 'node2-1',
            //         sourceAnchor: 1,
            //         targetAnchor: 0,
            //     },
            //     {
            //         source: 'node1',
            //         target: 'node2-2',
            //         sourceAnchor: 2,
            //         targetAnchor: 0,
            //     },
            //     {
            //         source: 'node2-1',
            //         target: 'node3-1',
            //         sourceAnchor: 2,
            //         targetAnchor: 0,
            //     },
            // ]
        }
        graph.data(data)
        graph.render()
        graph.setMode(ADD_EDGE_MODE)

        graph.on('node:click', (ev) => {
            const target = ev.target
            const name = target.get('name')
            if (name.endsWith('-answer-close-icon')) {
                // 小圆x
                const idx = Number(name.split('-')[0])
                const node = ev.item
                const curModel = node.getModel()
                curModel.answers = curModel.answers.filter((answer, index) => index !== idx)
                // sourceAnchor具有唯一性
                const curEdge = node.getOutEdges().find((edge) => {
                    const edgeModel = edge.getModel()
                    if (edgeModel.source === curModel.id && edgeModel.sourceAnchor === (idx + 1)) {
                        return true
                    }
                    return false
                })
                // 如果存在连接的edge则删除
                if (curEdge) {
                    graph.removeItem(curEdge)
                }
                // 重新绘制
                graph.update(ev.item, {
                    answers: curModel.answers,
                })
                console.log(graph.save())
                graph.data(graph.save())
                graph.render()
                // const answer = curModel.answers.find((answer, index) => index === idx)
                // answer.isRemove = true
                // graph.update(ev.item, {
                //     'custom-update': {
                //         type: 'remove',
                //         name: name,
                //     }
                // })
                // graph.refresh()
                // graph.render() 
                /* 
                    重新渲染可以实现删除，但是回到最初的布局位置 
                        可能的解决方法：使用自定义结点的update  新问题： 出现了两个绘制图 // 普通shape无法删除
                        其它方法： answer 独立化为 node -- 怎么组织信息呢？
                */
            }
        })

    </script>
</body>

</html>